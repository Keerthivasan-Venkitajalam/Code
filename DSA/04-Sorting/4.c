/*
 **************************** DO NOT EDIT THIS FILE ****************************
 ************ ANY CHANGES MADE WILL BE DISCARDED BEFORE EVALUATION *************

 * Question:
	In this question, we are going to implement another hybrid sorting algorithm.
	Given an array A of n integers, sort them in non-increasing order as follows.
		If n is less than 5, sort the array using INSERTION SORT.
		Otherwise, 
			Perform QUICK SORT using the last element in the array as pivot.
			After a partition step, if the number of elements in any of the
				partition becomes less than 5, sort that partition using 
				INSERTION SORT instead of QUICK SORT. 
	Also, print the total number of comparisons performed throughout the sorting process.
 * Instructions:
	Complete the function/s
		quickSortModified()
		insert()
		insertionSort()
	in the file sorting.c.
 * Execution Example/s:
	Enter the number of elements: 15
	Enter 15 elements: 9 3 1 7 3 8 7 2 3 5 8 9 2 4 5
	5 8
	[4 3 1 2 3 5 3 2]
	[7 8 9 8 7 9]
	2 2
	[2 1]
	[3 3 5 3 4]
	4 3
	[3 3 3]
	[5]
	9 5
	[7 8 9 8 7]
	7 1
	[7]
	[9 8 8]

	Sorted Array: [1 2 2 3 3 3 4 5 5 7 7 8 8 9 9]
	Total number of comparisons (including quickSort and insertionSort): 40
	
*/

#include <stdio.h>
#include <stdlib.h>

#include "sorting.h"
#include "structure.h"

int comparisons = 0;
int binarySearchCount = 0;

int main()
{
	int n;

	printf("Enter the number of elements: ");
	scanf("%d%*c", &n);

	int* A = malloc(n * sizeof(int));

	printf("Enter %d elements: ", n);
	readArray(A, n);

	quickSortModified(A, n);

	printf("\nSorted Array: ");
	printArray(A,n);

	printf("Total number of comparisons (including quickSort and insertionSort): %d\n", comparisons);

	return 0;
}